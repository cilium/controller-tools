From 13e8db40e2a3e7a7fe227dadbc81d68bf2cd3026 Mon Sep 17 00:00:00 2001
From: William McKinnerney <williammck@users.noreply.github.com>
Date: Mon, 31 Jan 2022 11:12:23 -0600
Subject: [PATCH] :bug: Skip unexported fields when generating CRDs (#584)

* Skip unexported fields when generating CRDs

* Add generator flag to skip unexported fields
---
 pkg/crd/gen.go                                |  8 +++-
 pkg/crd/parser.go                             |  5 ++-
 pkg/crd/parser_integration_test.go            |  5 ++-
 pkg/crd/schema.go                             | 26 +++++++----
 pkg/crd/schema_test.go                        |  2 +-
 pkg/crd/testdata/cronjob_types.go             | 44 +++++++++----------
 .../testdata.kubebuilder.io_cronjobs.yaml     | 18 ++++----
 pkg/crd/zz_generated.markerhelp.go            |  4 ++
 8 files changed, 65 insertions(+), 47 deletions(-)

diff --git a/pkg/crd/gen.go b/pkg/crd/gen.go
index 99598746..566a1289 100644
--- a/pkg/crd/gen.go
+++ b/pkg/crd/gen.go
@@ -41,6 +41,11 @@ const defaultVersion = v1
 
 // Generator generates CustomResourceDefinition objects.
 type Generator struct {
+	// IgnoreUnexportedFields indicates that we should skip unexported fields.
+	//
+	// Left unspecified, the default is false.
+	IgnoreUnexportedFields *bool `marker:",optional"`
+
 	// AllowDangerousTypes allows types which are usually omitted from CRD generation
 	// because they are not recommended.
 	//
@@ -85,7 +90,8 @@ func (g Generator) Generate(ctx *genall.GenerationContext) error {
 		Collector: ctx.Collector,
 		Checker:   ctx.Checker,
 		// Perform defaulting here to avoid ambiguity later
-		AllowDangerousTypes: g.AllowDangerousTypes != nil && *g.AllowDangerousTypes == true,
+		IgnoreUnexportedFields: g.IgnoreUnexportedFields != nil && *g.IgnoreUnexportedFields == true,
+		AllowDangerousTypes:    g.AllowDangerousTypes != nil && *g.AllowDangerousTypes == true,
 		// Indicates the parser on whether to register the ObjectMeta type or not
 		GenerateEmbeddedObjectMeta: g.GenerateEmbeddedObjectMeta != nil && *g.GenerateEmbeddedObjectMeta == true,
 	}
diff --git a/pkg/crd/parser.go b/pkg/crd/parser.go
index 164e4756..4c15de90 100644
--- a/pkg/crd/parser.go
+++ b/pkg/crd/parser.go
@@ -87,6 +87,9 @@ type Parser struct {
 	// TODO: Should we have a more formal mechanism for putting "type patterns" in each of the above categories?
 	AllowDangerousTypes bool
 
+	// IgnoreUnexportedFields specifies if unexported fields on the struct should be skipped
+	IgnoreUnexportedFields bool
+
 	// GenerateEmbeddedObjectMeta specifies if any embedded ObjectMeta should be generated
 	GenerateEmbeddedObjectMeta bool
 }
@@ -178,7 +181,7 @@ func (p *Parser) NeedSchemaFor(typ TypeIdent) {
 	// avoid tripping recursive schemata, like ManagedFields, by adding an empty WIP schema
 	p.Schemata[typ] = apiext.JSONSchemaProps{}
 
-	schemaCtx := newSchemaContext(typ.Package, p, p.AllowDangerousTypes)
+	schemaCtx := newSchemaContext(typ.Package, p, p.AllowDangerousTypes, p.IgnoreUnexportedFields)
 	ctxForInfo := schemaCtx.ForInfo(info)
 
 	pkgMarkers, err := markers.PackageMarkers(p.Collector, typ.Package)
diff --git a/pkg/crd/parser_integration_test.go b/pkg/crd/parser_integration_test.go
index 0903ec0c..2828c329 100644
--- a/pkg/crd/parser_integration_test.go
+++ b/pkg/crd/parser_integration_test.go
@@ -72,8 +72,9 @@ var _ = Describe("CRD Generation From Parsing to CustomResourceDefinition", func
 		reg := &markers.Registry{}
 		Expect(crdmarkers.Register(reg)).To(Succeed())
 		parser := &crd.Parser{
-			Collector: &markers.Collector{Registry: reg},
-			Checker:   &loader.TypeChecker{},
+			Collector:              &markers.Collector{Registry: reg},
+			Checker:                &loader.TypeChecker{},
+			IgnoreUnexportedFields: true,
 		}
 		crd.AddKnownTypes(parser)
 
diff --git a/pkg/crd/schema.go b/pkg/crd/schema.go
index d94bd707..4aa5f002 100644
--- a/pkg/crd/schema.go
+++ b/pkg/crd/schema.go
@@ -69,17 +69,19 @@ type schemaContext struct {
 	schemaRequester schemaRequester
 	PackageMarkers  markers.MarkerValues
 
-	allowDangerousTypes bool
+	allowDangerousTypes    bool
+	ignoreUnexportedFields bool
 }
 
 // newSchemaContext constructs a new schemaContext for the given package and schema requester.
 // It must have type info added before use via ForInfo.
-func newSchemaContext(pkg *loader.Package, req schemaRequester, allowDangerousTypes bool) *schemaContext {
+func newSchemaContext(pkg *loader.Package, req schemaRequester, allowDangerousTypes, ignoreUnexportedFields bool) *schemaContext {
 	pkg.NeedTypesInfo()
 	return &schemaContext{
-		pkg:                 pkg,
-		schemaRequester:     req,
-		allowDangerousTypes: allowDangerousTypes,
+		pkg:                    pkg,
+		schemaRequester:        req,
+		allowDangerousTypes:    allowDangerousTypes,
+		ignoreUnexportedFields: ignoreUnexportedFields,
 	}
 }
 
@@ -87,10 +89,11 @@ func newSchemaContext(pkg *loader.Package, req schemaRequester, allowDangerousTy
 // as this one, except with the given type information.
 func (c *schemaContext) ForInfo(info *markers.TypeInfo) *schemaContext {
 	return &schemaContext{
-		pkg:                 c.pkg,
-		info:                info,
-		schemaRequester:     c.schemaRequester,
-		allowDangerousTypes: c.allowDangerousTypes,
+		pkg:                    c.pkg,
+		info:                   info,
+		schemaRequester:        c.schemaRequester,
+		allowDangerousTypes:    c.allowDangerousTypes,
+		ignoreUnexportedFields: c.ignoreUnexportedFields,
 	}
 }
 
@@ -351,6 +354,11 @@ func structToSchema(ctx *schemaContext, structType *ast.StructType) *apiext.JSON
 	}
 
 	for _, field := range ctx.info.Fields {
+		// Skip if the field is not an inline field, ignoreUnexportedFields is true, and the field is not exported
+		if field.Name != "" && ctx.ignoreUnexportedFields && !ast.IsExported(field.Name) {
+			continue
+		}
+
 		jsonTag, hasTag := field.Tag.Lookup("json")
 		if !hasTag {
 			// if the field doesn't have a JSON tag, it doesn't belong in output (and shouldn't exist in a serialized type)
diff --git a/pkg/crd/schema_test.go b/pkg/crd/schema_test.go
index bd46858e..5b8fa03f 100644
--- a/pkg/crd/schema_test.go
+++ b/pkg/crd/schema_test.go
@@ -63,7 +63,7 @@ func transform(t *testing.T, expr string) *apiext.JSONSchemaProps {
 	pkg.NeedTypesInfo()
 	failIfErrors(t, pkg.Errors)
 
-	schemaContext := newSchemaContext(pkg, nil, true).ForInfo(&markers.TypeInfo{})
+	schemaContext := newSchemaContext(pkg, nil, true, false).ForInfo(&markers.TypeInfo{})
 	// yick: grab the only type definition
 	definedType := pkg.Syntax[0].Decls[0].(*ast.GenDecl).Specs[0].(*ast.TypeSpec).Type
 	result := typeToSchema(schemaContext, definedType)
diff --git a/pkg/crd/testdata/cronjob_types.go b/pkg/crd/testdata/cronjob_types.go
index f7aac8cb..80148f1e 100644
--- a/pkg/crd/testdata/cronjob_types.go
+++ b/pkg/crd/testdata/cronjob_types.go
@@ -32,7 +32,6 @@ import (
 	corev1 "k8s.io/api/core/v1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/runtime"
-	"k8s.io/apimachinery/pkg/util/intstr"
 )
 
 // EDIT THIS FILE!  THIS IS SCAFFOLDING FOR YOU TO OWN!
@@ -162,29 +161,12 @@ type CronJobSpec struct {
 	// +kubebuilder:validation:Schemaless
 	Schemaless []byte `json:"schemaless,omitempty"`
 
-	// This tests that an IntOrString can also have a pattern attached
-	// to it.
-	// This can be useful if you want to limit the string to a perecentage or integer.
-	// The XIntOrString marker is a requirement for having a pattern on this type.
-	// +kubebuilder:validation:XIntOrString
-	// +kubebuilder:validation:Pattern="^((100|[0-9]{1,2})%|[0-9]+)$"
-	IntOrStringWithAPattern *intstr.IntOrString `json:"intOrStringWithAPattern,omitempty"`
+	// This tests that unexported fields are skipped in the schema generation
+	unexportedField string
 
-	// Checks that nested maps work
-	NestedMap map[string]map[string]string `json:"nestedMap,omitempty"`
-
-	// Checks that multiply-nested maps work
-	NestedNestedMap map[string]map[string]map[string]string `json:"nestedNestedMap,omitempty"`
-
-	// Checks that maps containing types that contain maps work
-	ContainsNestedMapMap map[string]ContainsNestedMap `json:"nestedMapInStruct,omitempty"`
-
-	// Maps of arrays of things-that-arenâ€™t-strings are permitted
-	MapOfArraysOfFloats map[string][]bool `json:"mapOfArraysOfFloats,omitempty"`
-}
-
-type ContainsNestedMap struct {
-	InnerMap map[string]string `json:"innerMap,omitempty"`
+	// This tests that both unexported and exported inline fields are not skipped in the schema generation
+	unexportedStruct `json:",inline"`
+	ExportedStruct   `json:",inline"`
 }
 
 // +kubebuilder:validation:Type=object
@@ -235,6 +217,22 @@ type MinMaxObject struct {
 	Baz string `json:"baz,omitempty"`
 }
 
+type unexportedStruct struct {
+	// This tests that exported fields are not skipped in the schema generation
+	Foo string `json:"foo"`
+
+	// This tests that unexported fields are skipped in the schema generation
+	bar string
+}
+
+type ExportedStruct struct {
+	// This tests that exported fields are not skipped in the schema generation
+	Baz string `json:"baz"`
+
+	// This tests that unexported fields are skipped in the schema generation
+	qux string
+}
+
 type RootObject struct {
 	Nested NestedObject `json:"nested"`
 }
diff --git a/pkg/crd/testdata/testdata.kubebuilder.io_cronjobs.yaml b/pkg/crd/testdata/testdata.kubebuilder.io_cronjobs.yaml
index eaf91f5c..af3880b8 100644
--- a/pkg/crd/testdata/testdata.kubebuilder.io_cronjobs.yaml
+++ b/pkg/crd/testdata/testdata.kubebuilder.io_cronjobs.yaml
@@ -55,6 +55,9 @@ spec:
                 - name
                 - secondary
                 x-kubernetes-list-type: map
+              baz:
+                description: This tests that exported fields are not skipped in the schema generation
+                type: string
               binaryName:
                 description: This tests byte slice schema generation.
                 format: byte
@@ -124,16 +127,9 @@ spec:
                   a pointer to distinguish between explicit zero and not specified.
                 format: int32
                 type: integer
-              intOrStringWithAPattern:
-                anyOf:
-                - type: integer
-                - type: string
-                description: This tests that an IntOrString can also have a pattern
-                  attached to it. This can be useful if you want to limit the string
-                  to a perecentage or integer. The XIntOrString marker is a requirement
-                  for having a pattern on this type.
-                pattern: ^((100|[0-9]{1,2})%|[0-9]+)$
-                x-kubernetes-int-or-string: true
+              foo:
+                description: This tests that exported fields are not skipped in the schema generation
+                type: string
               jobTemplate:
                 description: Specifies the job that will be created when executing
                   a CronJob.
@@ -7312,12 +7308,14 @@ spec:
                 x-kubernetes-preserve-unknown-fields: true
             required:
             - associativeList
+            - baz
             - binaryName
             - canBeNull
             - defaultedObject
             - defaultedSlice
             - defaultedString
             - embeddedResource
+            - foo
             - jobTemplate
             - mapOfInfo
             - patternObject
diff --git a/pkg/crd/zz_generated.markerhelp.go b/pkg/crd/zz_generated.markerhelp.go
index db9f40f2..fee8de4b 100644
--- a/pkg/crd/zz_generated.markerhelp.go
+++ b/pkg/crd/zz_generated.markerhelp.go
@@ -33,6 +33,10 @@ func (Generator) Help() *markers.DefinitionHelp {
 			Details: "",
 		},
 		FieldHelp: map[string]markers.DetailedHelp{
+			"IgnoreUnexportedFields": {
+				Summary: "indicates that we should skip unexported fields. ",
+				Details: "Left unspecified, the default is false.",
+			},
 			"AllowDangerousTypes": {
 				Summary: "allows types which are usually omitted from CRD generation because they are not recommended. ",
 				Details: "Currently the following additional types are allowed when this is true: float32 float64 \n Left unspecified, the default is false",
-- 
2.41.0

